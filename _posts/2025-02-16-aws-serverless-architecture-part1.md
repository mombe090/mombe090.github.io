---
title: "AWS Serverless & Programmation Ã‰vÃ©nementielle : CrÃ©ez un Service de Transfert dâ€™Argent Mobile (Partie 1) ðŸ’°"
description: "Dans cet article (pratique), je vais vous montrer comment mettre en place une solution de transfert d'argent mobile (imaginaire) beaucoup utilisÃ© en Afrique en utilisant du serverless sur AWS. L'objectif principal Ã©tant de vous familiariser avec les concepts serverless tout en construisant une application pratique.<br/>"
categories: [aws, serverless]
tags: [terraform, aws, serverless, cloud, devops]
author: "mombe090"
image:
  path: /assets/img/header/serverless-part1.webp
---

## Introduction :
A la fin de cette sÃ©rie d'articles, vous aurez appris Ã  utiliser l'`infra-as-code` avec `Terraform` pour configurer et dÃ©ployer : <br /> 
- un Api Gateway sÃ©curisÃ© avec une `Lambda Authorizer` qui utilise un service d'authentication externe comme Auth0 <br />
- des fonctions Lambda pour gÃ©rer les 3 trois types de transactions suivants :
  - VÃ©rification de solde
  - DÃ©pÃ´t
  - Retrait
- une base de donnÃ©e `DynamoDB` <br />
- une file `SQS` pour enregistrer les transactions et les traiter plus tard de maniÃ¨re asynchrone, <br />
- La configuration de la journalisation (logging) avec `CloudWatch` pour surveiller et dÃ©boguer les fonctions Lambda <br />.
- Notification des utilisateurs :
  - Par SMS avec un service externe `Nimba SMS`
  - Par email en utilisant Amazon `Simple Email Service` (SES).

## Architecture :
Voici l'infrastructure que nous allons crÃ©er :
![Infrastructure](/assets/img/content/diagrame-serverless-p1.webp)
_Infrastructure Serverless Pour l'Application Fintech Imaginaire_

## PrÃ©requis :
- [Terraform](https://learn.hashicorp.com/tutorials/terraform/install-cli) version 1.10.0 ou supÃ©rieure
- [Nodejs](https://nodejs.org/en/download/) version 20 ou supÃ©rieure
- [Yarn](https://classic.yarnpkg.com/en/docs/install)) / [Npm](https://nodejs.org/en/download/)
- Compte AWS :
  - avec un utilisateur ayant le droit d'administrateur. [voir crÃ©er un compte AWS](https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-creating.html)
  - > **Note** : Une carte de crÃ©dit est nÃ©cessaire pour la vÃ©rification dâ€™identitÃ©. La plupart des ressources utilisÃ©es dans ce tutoriel sont serverless et ne gÃ©nÃ¨rent des coÃ»ts que si elles sont utilisÃ©es avec un certain volume.
- Avoir un compte Auth0 (j'utilise un compte gratuit) [voir crÃ©er un compte Auth0](https://auth0.com/signup).

- **Optionnel** : 
  - Avoir un compte `NimbaSMS`  avec un pack sms active (ou un autre fournisseur de sms quelque soit le pays). [CrÃ©er un compte NimbaSMS](https://www.nimbasms.com/) ou autre fournisseur de sms.

  - Avoir un nom de domaine achetÃ© sur AWS ou un autre fournisseur. [Mais l'intÃ©gration est plus simple si le domaine est AWS](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/domain-register.html).
    > Par dÃ©faut, lâ€™API Gateway gÃ©nÃ¨re un domaine pour vos APIs. Si vous disposez dâ€™un nom de domaine, vous pouvez le mapper Ã  votre API Gateway au lieu dâ€™utiliser le domaine par dÃ©faut.
  - Outils recommandÃ©s pour le dÃ©veloppement :
    Pour faciliter le dÃ©veloppement local et le cycle de dÃ©ploiement, les outils suivants sont recommandÃ©s :

    - [Devbox](https://www.jetpack.io/devbox) : pour configurer des environnements de dÃ©veloppement isolÃ©s.
    - [Taskfile](https://taskfile.dev/) : pour automatiser les tÃ¢ches de dÃ©ploiement et de dÃ©veloppement.
    - [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html) : utiliser pour crÃ©er le backend S3 de terraform.
    - [Direnv](https://direnv.net/docs/installation.html) : pour gÃ©rer les variables d'environnement le dossier dev 
    - [Aws SAM ](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html) : pour gÃ©nÃ©rer un projet typescript prÃªt.
  
    
## Contexte :
Aujourdâ€™hui, on peut dire que la transition des datacenters traditionnels vers le cloud est en plein essor. La plupart des entreprises ont choisi de suivre cette tendance en lâ€™adoptant pour bÃ©nÃ©ficier des avantages quâ€™il apporte. Pour en savoir plus sur les avantages du cloud, [consulter cet article de GCP](https://cloud.google.com/learn/advantages-of-cloud-computing?hl=fr). <br>

[Amazon](https://amazon.com) a Ã©tÃ© le premier Ã  se lancer dans le cloud computing avec son service EC2 (Elastic Compute Cloud) en 2006, suivi de S3 (Simple Storage Service) en 2007. Aujourdâ€™hui, AWS (Amazon Web Services) est devenu une entreprise Ã  part entiÃ¨re, offrant une plÃ©thore de services.

Avec un modÃ¨le dâ€™affaires basÃ© sur la facturation Ã  lâ€™heure pour lâ€™utilisation des ressources, des services comme EC2 se sont rapidement imposÃ©s comme des solutions incontournables. DÃ©sormais, au lieu de gÃ©rer des serveurs physiques, on peut louer des serveurs virtuels sur AWS pour une durÃ©e dÃ©terminÃ©e.

Cependant, aprÃ¨s plusieurs annÃ©es dâ€™utilisation de ce modÃ¨le, les entreprises ont commencÃ© Ã  se poser une question essentielle : pourquoi payer pour des ressources qui ne sont pas utilisÃ©es en permanence ? Par exemple, lors des pÃ©riodes de faible activitÃ© comme les nuits, les weekends, etc.

En 2014, AWS a lancÃ© un nouveau modÃ¨le Serverless de Facturation et service (Function as a Service) qui permet de ne payer que ce qu'on utilise avec [AWS Lambda](https://aws.amazon.com/fr/lambda/).
Les lambdas sont des fonctions qui peuvent Ãªtre dÃ©clenchÃ©es par des Ã©vÃ©nements comme la rÃ©ception d'un fichier sur S3, un changement de status sur un serveur, ou encore par un appel HTTP etc. <br>

> Il faut noter qu'AWS est le leader du marchÃ© du cloud devant des concurents comme Azure (Microsoft Azure) et GCP (Google Cloud Platform). <br>

## PrÃ©sentation des outils utilisÃ©s :

### Auth0 :
[Auth0](https://auth0.com) est une plateforme d'authentification et d'autorisation qui permet aux dÃ©veloppeurs de sÃ©curiser leurs applications web, mobiles et API. <br>
Il permet par exemple dans notre cas, de sÃ©curiser l'API qu'on s'apprÃªte Ã  dÃ©ployer. <br>

### Nimba SMS :
[Nimba SMS](https://www.nimbasms.com/) est une plateforme de notification par SMS Ã  moindre coÃ»t. <br>
Excellente documentation avec une integration trÃ¨s simple, c'est du niveau de **Twilio** mais avec un coÃ»t bien infÃ©rieur. <br>


### Services AWS :

Ci-dessous la liste des services AWS utilisÃ©s dans ce projet avec leurs rÃ´les et coÃ»ts respectifs :


| Nom         | RÃ´le                                 | CoÃ»t sur Canada Central                                                                                                                                                                                 |
|-------------|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| API Gateway | CrÃ©ation d'API                       | $3.50/333 M requÃªtes / mois  [Documentation](https://aws.amazon.com/fr/api-gateway/pricing/)                                                                                                            |
| Lambda      | Function contenant la logique MÃ©tier | $0.20/1 M requÃªtes / mois  [Documentation](https://aws.amazon.com/fr/lambda/pricing/)                                                                                                                   |
| CloudWatch  | Monitoring des logs et des erreurs   | 0,55 USD par Go / mois  [Documentation](https://aws.amazon.com/fr/cloudwatch/pricing/)                                                                                                                  |
| Route 53    | DNS                                  | 0,50 $ / zone hÃ©bergÃ©e / mois  [Documentation](https://aws.amazon.com/fr/route53/pricing/)                                                                                                              | |
| DynamoDB    | Base de donnÃ©es                      | en fonction du mode de stockage et du nombre de requÃªtes  [Documentation](https://aws.amazon.com/fr/dynamodb/pricing/)                                                                                  |
| Sqs         | File d'attente                       | 0,40 $ file standard, de  1 million Ã  100 milliards de demandes/mois   [Documentation](https://aws.amazon.com/fr/sqs/pricing/)                                                                          |
| KMS         | Chiffrement des donnÃ©es              | 0,03 $ pour 10 000 demandes  [Documentation](https://aws.amazon.com/fr/kms/pricing/)                                                                                                                    |
| SSM         | Gestion des parametres et secrets    | grattuit pour le standard et 0,05 USD par paramÃ¨tre avancÃ© par mois (au prorata horaire si le paramÃ¨tre est stockÃ© moins d'un mois) [Documentation](https://aws.amazon.com/fr/systems-manager/pricing/) |
| SES         | Envoie et reception d'Email          | 0,10 $/1 000 e-mails  [Documentation](https://aws.amazon.com/fr/ses/pricing/)                                                                                                                           |
| IAM         | Gestion des utilisateurs et roles    | Gratuit   [Documentation](https://aws.amazon.com/fr/iam/pricing/) 


### Structure du projet :

Voici Ã  quoi pourrai ressembler la structure finale du projet :
```shell
â”œâ”€â”€ infra-as-code
â”‚Â Â  â”œâ”€â”€ environments
â”‚Â Â  â”‚Â Â  â””â”€â”€ dev
â”‚Â Â  â””â”€â”€ modules
â”‚Â Â      â””â”€â”€ common
â”œâ”€â”€ lambda-src
â”‚Â Â  â”œâ”€â”€ authorizer
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ unit
â”‚Â Â  â”œâ”€â”€ get-account-info
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ unit
â”‚Â Â  â””â”€â”€ init-user-account
â”‚Â Â      â”œâ”€â”€ src
â”‚Â Â      â”œâ”€â”€ tests
â”‚Â Â      â”‚Â Â  â””â”€â”€ unit
```

Pour reprendre la structure ci-haut, exÃ©cuter les commandes suivantes :

```shell
    # Dossier des environnements de votre infrastructure. Si vous avez plusieurs environnements
    # (dev, test, prod, etc.), vous pouvez les crÃ©er manuellement ou utiliser Terragrunt pour
    # gÃ©nÃ©rer les environnements dynamiquement.
    mkdir -p infra-as-code/environments/dev/

    # Dossier utilisÃ© pour stocker le template de la spÃ©cification OpenAPI de l'API Gateway.
    # Ce template servira de base pour dÃ©finir les endpoints et les configurations de l'API.
    mkdir -p infra-as-code/modules/common/templates/
    
    # Dossier utilisÃ© pour stocker les projets Node.js des fonctions Lambda.
    # Chaque sous-dossier correspondra au code source d'une fonction Lambda spÃ©cifique.
    mkdir -p lambda-src/
```

# Installation des outils nÃ©cessaires :
Dans cet article, j'utilise [devbox](https://www.jetpack.io/devbox/) pour installer les diffÃ©rents outils dans un environnement isolÃ©, il est basÃ© sur [nix](https://nixos.org/).
Vous pouvez utiliser votre gestionnaire de paquet prÃ©fÃ©rÃ© pour installer les outils nÃ©cessaires ou tÃ©lÃ©charger les binaires ou les scripts d'installation directement sur le site officiel de chaque outil.

> **Note** : Lâ€™un des avantages majeurs dâ€™un outil comme Devbox est sa capacitÃ© Ã  crÃ©er des environnements isolÃ©s et reproductibles. Cela est particuliÃ¨rement utile pour les projets open source ou les projets qui doivent Ãªtre partagÃ©s avec dâ€™autres dÃ©veloppeurs. En quelque sorte, Devbox est Ã  la gestion des paquets ce que Docker est Ã  la gestion des conteneurs.




```shell
# Cette commande permet d'initialiser devbox dans le projet en crÃ©ant un fichier de configuration devbox.json
devbox init 

# Ajout des diffÃ©rents paquets nÃ©cessaires
devbox add git
devbox add terraform@1.10.5
devbox add devenv@1.4 
devbox add nodejs_22
devbox add aws-sam-cli@1.132.0 
devbox add go-task@3.41.0
devbox add yarn@1.22.22
```

L'installation des paquets peut prendre un certain temps si c'est la premiÃ¨re fois que vous utilisez devbox, nix ou un gestionnaire de paquet similaire.
Une fois l'installation terminÃ©e, vous pouvez lancer la commande suivante pour activer l'environnement virtuel.

```shell
devbox shell

# exit pour sortir de l'environnement virtuel
```
### CrÃ©ation de l'infrastructure :

Pour faire du serverless sur AWS, il existe plusieurs outils et frameworks sur le marchÃ© dont [CloudFormation](https://aws.amazon.com/fr/cloudformation/), AWS CDK, [AWS SAM](https://aws.amazon.com/fr/serverless/sam/) maintenue par AWS et d'autres comme [Serverless Framework](https://www.serverless.com/), [Terraform](https://www.terraform.io/)/[OpenTofu](https://opentofu.org/) etc. <br>

Nous allons utiliser terraform, l'outil de provisionnement d'infrastructure que nous avons installÃ© prÃ©cÃ©demment pour provisionner notre infrastructure. <br>
> Terraform 1.10.5 est la version utilisÃ© dans cet article, il supporte l'utilisation de S3 comme backend pour stocker l'Ã©tat de l'infrastructure avec le lock dynamique native de S3 sans utiliser de base de donnÃ©es comme dynamodb.
> D'habitude, on utilise opentofu mais la derniÃ¨re version d'opentofu ne supporte pas encore l'utilisation de S3 comme backend avec le lock dynamique native.
> Suivre l'issue sur le repo d'opentofu pour le support du lock_file native de S3 : https://github.com/opentofu/opentofu/issues/599

Nous allons utiliser un bucket s3 comme backend pour stocker l'Ã©tat de l'infrastructure, il faut donc crÃ©er un bucket s3 avant de pouvoir crÃ©er l'infrastructure. <br />

Pour communiquer avec l'API d'AWS via la CLI ou Terraform, nous avons besoin de configurer les credentials. <br />
J'utilise l'outil **direnv** pour gÃ©rer les variables d'environnement,  [Voir comment configurer les credentials AWS avec votre OS](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html) <br />

- Si vous optez pour l'outil direnv, vous devez crÃ©er un fichier `.envrc` dans le dossier `[infra-as-code/environments/dev/.envrc]() et rajouter le contenu suivant :
 
```shell
export AWS_ACCESS_KEY_ID=votre-access-key-id
export AWS_SECRET_ACCESS_KEY=votre-secret-access-key
export AWS_DEFAULT_REGION=votre-region
```

Puis une fois dans le dossier **infra-as-code/environments/dev** : `direnv allow` pour activer les variables d'environnement.
> **Note** : Le fichier `.envrc` doit Ãªtre ignorÃ© par git, donc il faut ajouter une ligne dans le fichier `.gitignore` : `*.envrc **/.envrc`
 
- Maintenant que les crÃ©dentials sont configurÃ©s, nous pouvons crÃ©er le bucket s3 qui vas servir de backend pour terraform: 
- > **Note** : Terraform offre Terraform Cloud et Terraform Enterprise pour gÃ©rer les Ã©tats des infrastructures. 

  ```shell
    BUCKET_NAME="aws-serverless-fintech-solution-statefile-bucket-xsxd3"
    
    REGION="ca-central-1" # remplacer par la rÃ©gion la plus proche de vous
    
    # Creation du bucket s3
    aws s3api create-bucket \
      --bucket $BUCKET_NAME \
      --region $REGION \
      --create-bucket-configuration LocationConstraint=$REGION
    
    # Activer le versioning sur le bucket s3
    aws s3api put-bucket-versioning \
      --bucket $BUCKET_NAME \
      --versioning-configuration Status=Enabled
      
    #List buckets pour verifier que le bucket a bien Ã©tÃ© crÃ©Ã©
    aws s3api list-buckets
  ```
- Avec la Console Web d'AWS :
  Sur le champ de recherche, tapez `s3` et cliquez sur dessus, puis sur le button jaune `create bucket`, remplissez le champ `bucket name` avec le nom du bucket que vous avez choisi, sur la section `Bucket Versioning` cliquez sur `Enable` puis sur `create bucket`.
  > Activer le versioning sur le bucket s3 est une bonne pratique pour Ã©viter la perte de donnÃ©es ou en cas corruption du statefile de terraform on peut revenir Ã  une version antÃ©rieure.



## CrÃ©ation des diffÃ©rents composants de l'infrastructure et leurs intÃ©grations :

- ## CrÃ©ation d'une clÃ© de cryptage (AWS KMS) :
  Nous allons crÃ©er une clÃ© de cryptage unique pour l'ensemble des ressources de notre infrastructure (AWS KMS).

  [infra-as-code/modules/common/00-kms.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/00-kms.tf) :
  
  ```terraform
  
  #RÃ©cupÃ¨re l'ID du compte AWS
  data "aws_caller_identity" "current" {}
  
  data "aws_iam_policy_document" "kms_policy_document" {
    statement {
      sid    = uuidv5("dns", "kms_policy_document_root")
      effect = "Allow"
      actions = [
        "kms:*"
      ]
      resources = [
        "*"
      ]
      principals {
        type = "AWS"
        identifiers = [
          "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root",
        ]
      }
    }
  }
  
  resource "aws_kms_key" "this" {
    description = "Cle d'encryption pour les donnÃ©es"
    policy      = data.aws_iam_policy_document.kms_policy_document.json
  }
  
  resource "aws_kms_alias" "this" {
    name          = "alias/fintech-solution"
    target_key_id = aws_kms_key.this.key_id
  }
  ```
  

- ## Api Gateway :
  Aws support 4 types d'Api Gateway :
  - REST API
  - HTTP API
  - WebSocket API
  - Rest API Private

  `Rest API` est celui qu'on vas utiliser pour ce projet, vous pouvez lire cette [documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html?icmpid=apigateway_console_help) pour mieux faire le choix entre les 4 types.

  - AWS support la spÃ©cificaton OpenApi 3.0 pour la dÃ©finition des endpoints de l'Api Gateway, donc c'est ce que j'utiliserai.
  - [infra-as-code/modules/common/templates/endpoints.oas.yaml](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/templates/endpoints.oas.yaml) :

  ```yaml
  openapi: 3.0.3
  
  info:
    title: API Argent Mobile
    description: Cette API est juste un prototype pour la gestion des comptes Argent Mobile et utilisÃ© comme exemple pour la formation DevSecOps
    version: 1.0.0
  servers:
    - url: "https://api.doudhal-devops.com/v1"
  
  components:
    # Utilisation de l'authentification JWT pour sÃ©curiser les endpoints
    securitySchemes:
      JwtAuthorizer:
        type: apiKey
        name: Authorization
        in: header
        x-amazon-apigateway-authtype: "custom"
        x-amazon-apigateway-authorizer:
          type: "token"
          
          # L'ARN de la fonction Lambda qui va vÃ©rifier le token JWT (lambda-authorizer)
          authorizerUri: "arn:aws:apigateway:${aws_region}:lambda:path/2015-03-31/functions/${jwt_authorizer_lambda_arn}/invocations"
          authorizerResultTtlInSeconds: 250
          identitySource: "method.request.header.Authorization"
          identityValidationExpression: "^Bearer\\s[a-zA-Z0-9._-]+$"
  
  paths:
    /get-account-info/msisdn/{msisdn}:
      get:
        operationId: getAccountInfo
        description: Obtenir les informations sur la solde d'argent mobile d'un numÃ©ro de tÃ©lÃ©phone
        
        # Pour protÃ©ger cette route, on ajoute la sÃ©curitÃ© JwtAuthorizer dÃ©fini plus haut
        security:
          - JwtAuthorizer: []
  
        # Cette prend juste en path paramÃ¨tre le numÃ©ro de tÃ©lÃ©phone du client
        parameters:
          - name: msisdn
            in: path
            required: true
            description: Le numÃ©ro de telephone du client
            schema:
              type: string
        
        # Cette section reserve pour l'intÃ©gration avec le backend (ici une lambda get-account-info) 
        # https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html
        x-amazon-apigateway-integration:
          credentials: "${api_gateway_role_arn}"
          uri: "arn:aws:apigateway:${aws_region}:lambda:path/2015-03-31/functions/${get_account_info_lambda_arn}/invocations"
          passthroughBehavior: "when_no_match"
          httpMethod: "POST"
          
          # Vue le get-account-info est sensible, le client veut toute de suite voir son solde, on met cette intÃ©gration synchrnone
          type: "aws_proxy"
          
        responses:
          "200":
            description: OK
            content: {}
            
        # Pour les autres codes d'erreur, on renvoie une rÃ©ponse par dÃ©faut
  
  ```

  - Le terraform associÃ© est dans [infra-as-code/modules/common/01-gateway-api.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/01-gateway-api.tf) :
  
  ```terraform
  locals {
    api_gw_name = "fintech-solution-api"
    get_acount_info_lambda_name = "get-account-info"
  }
  
  data "aws_iam_policy_document" "api_gw_assume_role" {
    #Section de dÃ©finition du rÃ´le assumption pour le service API Gateway
    statement {
      effect = "Allow"
  
      principals {
        type        = "Service"
        identifiers = ["apigateway.amazonaws.com"]
      }
  
      actions = ["sts:AssumeRole"]
    }
  }
  
  data "aws_iam_policy_document" "api_gw_policy_document" {
    #Section de dÃ©finition des permissions pour le service API Gateway, pour toutes intÃ©grations que l'on va crÃ©er
    statement {
      effect = "Allow"
  
      actions = [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:DescribeLogGroups",
        "logs:DescribeLogStreams",
        "logs:PutLogEvents",
        "logs:GetLogEvents",
        "logs:FilterLogEvents",
      ]
  
      resources = ["*"]
    }
  
    statement {
      effect = "Allow"
  
      actions = [
        "lambda:InvokeFunction"
      ]
  
      resources = [
        "arn:aws:lambda:${var.aws_region}:${var.aws_account_id}:function:${local.get_acount_info_lambda_name}"
      ]
    }
  }
  
  data "template_file" "endpoints" {
    # Conversion du fichier endpoints.oas.yaml en template terraform
    template = file("${path.module}/templates/endpoints.oas.yaml")
  
    vars = {
      api_gateway_role_arn        = aws_iam_role.gateway_rest_api_role.arn
      jwt_authorizer_lambda_arn   = aws_lambda_function.lambda_authorizer.arn
      get_account_info_lambda_arn = "arn:aws:lambda:${var.aws_region}:${var.aws_account_id}:function:${local.get_acount_info_lambda_name}"
      aws_region                  = var.aws_region
    }
  }
  
  # CrÃ©ation du role aws pour l'api gateway
  resource "aws_iam_role" "gateway_rest_api_role" {
    name               = "${local.api_gw_name}-role"
    assume_role_policy = data.aws_iam_policy_document.api_gw_assume_role.json
  }
  
  #CrÃ©ation de la policy pour l'api gateway
  resource "aws_iam_policy" "api_gw_policy" {
    name   = "${local.api_gw_name}-policy"
    policy = data.aws_iam_policy_document.api_gw_policy_document.json
  }
  
  # Attachement de la policy au role de l'api gateway
  resource "aws_iam_policy_attachment" "api_gw_policy_attachment" {
    name = "${local.api_gw_name}-policy-attachment"
    roles = [
      aws_iam_role.gateway_rest_api_role.name
    ]
    policy_arn = aws_iam_policy.api_gw_policy.arn
  }
  
  # CrÃ©ation des logs d'exÃ©cution de l'api gateway dans cloudwatch
  resource "aws_cloudwatch_log_group" "this" {
    name              = "API-Gateway-Execution-Logs_${aws_api_gateway_rest_api.this.id}/dev"
    retention_in_days = 1
  }
  
  # CrÃ©ation de l'api gateway account l'autoriser Ã  pusher les logs dans cloudwatch
  resource "aws_api_gateway_account" "this" {
    cloudwatch_role_arn = aws_iam_role.gateway_rest_api_role.arn
  }
  
  # CrÃ©ation de l'api gateway avec le l'OpenApi Spec
  resource "aws_api_gateway_rest_api" "this" {
    body = data.template_file.endpoints.rendered
  
    name = local.api_gw_name
  
    endpoint_configuration {
      # On utilise un endpoint regional pour Ã©viter les coÃ»ts supplÃ©mentaires, mais vous voulez aller large et utiliser un endpoint edge
      types = ["REGIONAL"]
    }
  }
  
  # Activation des mÃ©triques et le log level Ã  INFO, si vous voulez moins de logs, vous pouvez mettre ERROR ou OFF
  resource "aws_api_gateway_method_settings" "this" {
    rest_api_id = aws_api_gateway_rest_api.this.id
    stage_name  = aws_api_gateway_stage.this.stage_name
    method_path = "*/*"
  
    settings {
      metrics_enabled = true
      logging_level   = "INFO"
    }
  }
  
  # DÃ©ploiement de l'api gateway, on s'assure qu'a chaque fois l'OAS change, le dÃ©ploiement se fait
  resource "aws_api_gateway_deployment" "this" {
    rest_api_id = aws_api_gateway_rest_api.this.id
  
    triggers = {
      redeployment = sha1(jsonencode(aws_api_gateway_rest_api.this.body))
    }
  
    lifecycle {
      create_before_destroy = true
    }
  }
  
  # CrÃ©ation du stage de l'api gateway, ici j'utilise dev mais vous pouvez utiliser prod, staging, etc.
  resource "aws_api_gateway_stage" "this" {
    deployment_id = aws_api_gateway_deployment.this.id
    rest_api_id   = aws_api_gateway_rest_api.this.id
    stage_name    = "dev"
  
    # On active les logs au format json, il y a d'autres formats disponibles
    # https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html#set-up-access-logging-permissions
    access_log_settings {
      destination_arn = aws_cloudwatch_log_group.this.arn
      format          = jsonencode({ "requestId":"$context.requestId", "extendedRequestId":"$context.extendedRequestId","ip": "$context.identity.sourceIp", "caller":"$context.identity.caller", "user":"$context.identity.user", "requestTime":"$context.requestTime", "httpMethod":"$context.httpMethod", "resourcePath":"$context.resourcePath", "status":"$context.status", "protocol":"$context.protocol", "responseLength":"$context.responseLength" })
    }
  
    depends_on = [aws_api_gateway_account.this, aws_cloudwatch_log_group.this]
  }
  
  # CrÃ©ation du domaine personnalisÃ© pour l'api gateway, si seulement vous avez un domaine.
  resource "aws_api_gateway_domain_name" "this" {
    count = var.apply_custom_domain ? 1 : 0
  
    domain_name              = "api.${var.domain}"
    regional_certificate_arn = aws_acm_certificate.this[0].arn
  
    endpoint_configuration {
      types = ["REGIONAL"]
    }
  
    # On ajoute le certificat ssl pour le domaine personnalisÃ© avec l'Authority Certificate Manager (ACM) d"AWS qui est truster par la plupart des navigateurs et outils modernes.
    # On doit valider le certificat avec ACM avant de pouvoir l'utiliser avec API Gateway.
    #voir le fichier 02-route53.tf
    depends_on = [aws_acm_certificate.this, aws_acm_certificate_validation.this]
  }
  
  #Association du domaine personnalisÃ© avec l'API Gateway.
  resource "aws_api_gateway_base_path_mapping" "this" {
    count = var.apply_custom_domain ? 1 : 0
  
    api_id      = aws_api_gateway_rest_api.this.id
    stage_name  = aws_api_gateway_stage.this.stage_name
    domain_name = aws_api_gateway_domain_name.this[0].domain_name
  }
  
  ```

  - Ajout d'un sous domaine et son certificat ssl [infra-as-code/modules/common/02-route53.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/02-route53.tf) :

  ```terraform
  data "aws_route53_zone" "this" {
    count = var.apply_custom_domain ? 1 : 0
  
    name         = var.domain
  }
  
  # CrÃ©ation de ligne du nom de domaine dans la zone DNS route53 et le target est l'api gateway (Regional)
  # https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_domain_name#regional-acm-certificate
  resource "aws_route53_record" "this" {
    count = var.apply_custom_domain ? 1 : 0
  
    name    = "api.${var.domain}"
    type    = "A"
    zone_id = data.aws_route53_zone.this[0].zone_id
  
    alias {
      evaluate_target_health = true
      name                   = aws_api_gateway_domain_name.this[0].regional_domain_name
      zone_id                = aws_api_gateway_domain_name.this[0].regional_zone_id
    }
  }
  
  resource "aws_acm_certificate" "this" {
    count = var.apply_custom_domain ? 1 : 0
  
    domain_name               = "api.${var.domain}"
    subject_alternative_names = ["api.${var.domain}"]
    validation_method         = "DNS"
  }
  
  resource "aws_acm_certificate_validation" "this" {
    certificate_arn   = aws_acm_certificate.this[0].arn
  }
  
  ```

  - ### DÃ©finition de lambda authorizer (Infra et Code Source ) :

    Les lambdas sont des resources particuliÃ¨res, en plus du terraform pour la dÃ©ployer, elle requiert aussi du code applicatif pour la logique mÃ©tier qu'elle doit faire, on le verra dans la section suivante. 

  - le code infra : [infra-as-code/modules/common/03-lambda-authorizer.lambda.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/03-lambda-authorizer.lambda.tf) :

  ```terraform
      locals {
        authorizer_lambda_name = "lambda-authorizer"
      }
      
      data "aws_iam_policy_document" "lambda_authorizer_assume_role" {
        statement {
          effect = "Allow"
      
          principals {
            type        = "Service"
            identifiers = ["lambda.amazonaws.com"]
          }
      
          actions = ["sts:AssumeRole"]
        }
      }
      
      data "aws_iam_policy_document" "lambda_authorizer_policy_document" {
        statement {
          effect = "Allow"
      
          actions = [
            "logs:CreateLogGroup",
            "logs:CreateLogStream",
            "logs:PutLogEvents"
          ]
      
          resources = [
            "arn:aws:logs:${var.aws_region}:${var.aws_account_id}:log-group:/aws/lambda/${local.authorizer_lambda_name}:*"
          ]
        }
      }
      
      resource "aws_iam_policy" "lambda_authorizer_policy" {
        name   = "${local.authorizer_lambda_name}-policy"
        policy = data.aws_iam_policy_document.lambda_authorizer_policy_document.json
      }
      
      resource "aws_iam_role" "lambda_authorizer_role" {
        name               = "${local.authorizer_lambda_name}-role"
        assume_role_policy = data.aws_iam_policy_document.lambda_authorizer_assume_role.json
      }
      
      resource "aws_iam_policy_attachment" "lambda_authorizer_policy_attachment" {
        name       = "${local.authorizer_lambda_name}-policy-attachment"
        roles      = [aws_iam_role.lambda_authorizer_role.name]
        policy_arn = aws_iam_policy.lambda_authorizer_policy.arn
      }
      
      resource "aws_lambda_function" "lambda_authorizer" {
        filename      = "${path.module}/dist/authorizer.zip"
        function_name = local.authorizer_lambda_name
        role          = aws_iam_role.lambda_authorizer_role.arn
        handler       = "app.lambdaHandler"
        kms_key_arn = aws_kms_key.this.arn
      
        source_code_hash = filebase64sha256("${path.module}/dist/authorizer.zip")
      
        runtime = "nodejs22.x"
      
        environment {
          variables = {
            ISSUER_URI           = var.issuer_uri,
            JWKS_URI             = var.jwks_uri,
            AUDIENCE             = var.audience,
            POWERTOOLS_LOG_LEVEL = "INFO"
          }
        }
      }
      
      resource "aws_lambda_permission" "allow_api_gw_to_invoke_authorizer" {
        action        = "lambda:InvokeFunction"
        function_name = aws_lambda_function.lambda_authorizer.function_name
        principal     = "apigateway.amazonaws.com"
        source_arn    = "${aws_api_gateway_rest_api.this.execution_arn}/*"
      }
  
    ``` 

  - ### Initialisation du code de la lambda authorizer :
  Nous allons utiliser TypeScript (avec Node.js) comme langage de programmation pour ce projet. Pour dÃ©marrer rapidement, nous utiliserons AWS SAM (Serverless Application Model) afin de gÃ©nÃ©rer un code de base incluant quelques bonnes pratiques et configurations essentielles, telles que :

   - tsconfig : pour la configuration de TypeScript,

   - Prettier : pour le formatage du code,

   - ESLint : pour la vÃ©rification de la qualitÃ© du code.

   Une fois ce code de dÃ©part gÃ©nÃ©rÃ©, nous le modifierons pour utiliser Terraform comme outil de dÃ©ploiement.

  ```shell
  
  cd lambda-src
  sam init --runtime nodejs22.x --dependency-manager npm  --package-type Zip  --name tmp-sam
  Which template source would you like to use?
          1 - AWS Quick Start Templates
          2 - Custom Template Location
  Choice: 1
  
  Choose an AWS Quick Start application template
          1 - Hello World Example
          2 - GraphQLApi Hello World Example
          3 - Hello World Example with Powertools for AWS Lambda
          4 - Multi-step workflow
          5 - Standalone function
          6 - Scheduled task
          7 - Data processing
          8 - Serverless API
          9 - Full Stack
          10 - Lambda Response Streaming
  Template: 1
  
  Select your starter template
          1 - Hello World Example
          2 - Hello World Example TypeScript
  Template: 2
  
  Would you like to enable X-Ray tracing on the function(s) in your application?  [y/N]: n
  
  Would you like to enable monitoring using CloudWatch Application Insights?
  For more info, please view https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-application-insights.html [y/N]: n
  
  Would you like to set Structured Logging in JSON format on your Lambda functions?  [y/N]: y
  Structured Logging in JSON format might incur an additional cost. ....
  
  ```
  Une fois que la gÃ©nÃ©ration est terminÃ©e, rÃ©cupÃ©rer le dossier projet typescript gÃ©nÃ©rÃ© :

  ```bash
  #Suppression des fichiers dont on a pas besoin
  rm -f tmp-sam/.gitignore  tmp-sam/samconfig.toml  tmp-sam/README.md tmp-sam/template.yaml
  cp -r tmp-sam/* .
  rm -rf tmp-sam
  
  # Renommer le projet, crÃ©er un dossier src et y dÃ©placer le fichier app.ts
  mv hello-world authorizer
  cd authorizer && mkdir src && mv app.ts src
  
  # L'arborescence ressemble Ã  Ã§a :
  â”œâ”€â”€ jest.config.ts
  â”œâ”€â”€ package-lock.json
  â”œâ”€â”€ package.json
  â”œâ”€â”€ src
  â”‚Â Â  â””â”€â”€ app.ts
  â”œâ”€â”€ tests
  â”‚Â Â  â””â”€â”€ unit
  â”‚Â Â      â””â”€â”€ test-handler.test.ts
  â””â”€â”€ tsconfig.json
  
  # Installation des diffÃ©rents dÃ©pendances :
  yarn add @aws-lambda-powertools/logger jsonwebtoken jwks-rsa
  ou 
  npm install @aws-lambda-powertools/logger jsonwebtoken jwks-rsa
  
  ```

  Au final le `package.json` ressemble Ã  Ã§a, j'ai rajoutÃ© dans la section scripts, un script `build` qui utilise `esbuild` pour transpiler le code typescript en javascript.
  ```json
  {
    "name": "authorizer",
    "version": "1.0.0",
    "description": "Lambda charger de l'authorization",
    "main": "src/app.js",
    "repository": "https://github.com/mombe090/blog-source-code.git ",
    "author": "Mamadou Yaya DAILLO @generated-with-sam-cli",
    "license": "MIT",
    "scripts": {
      "build": "esbuild src/app.ts --sourcemap --bundle --platform=node --target=es2020 --minify --external:aws-sdk --outfile=dist/app.js ",
      "unit": "jest",
      "lint": "eslint 'src/**/*.ts' --quiet --fix",
      "compile": "tsc",
      "test": "npm run compile && npm run unit"
    },
    "dependencies": {
      "@aws-lambda-powertools/logger": "^2.13.1",
      "esbuild": "^0.14.14",
      "jsonwebtoken": "^9.0.2",
      "jwks-rsa": "^3.1.0"
    },
    "devDependencies": {
      "@jest/globals": "^29.2.0",
      "@types/aws-lambda": "^8.10.92",
      "@types/jest": "^29.2.0",
      "@types/node": "^20.5.7",
      "@typescript-eslint/eslint-plugin": "^5.10.2",
      "@typescript-eslint/parser": "^5.10.2",
      "eslint": "^8.8.0",
      "eslint-config-prettier": "^8.3.0",
      "eslint-plugin-prettier": "^4.0.0",
      "jest": "^29.2.1",
      "prettier": "^2.5.1",
      "ts-jest": "^29.0.5",
      "ts-node": "^10.9.1",
      "typescript": "^4.8.4"
    }
  }
  
  ```

  Pour le code de la lambda elle-mÃªme, pour simplifier, j'ai choisi de mettre le code dans un seul fichier [lambda-src/authorizer/src/app.ts](), mais AWS rÃ©commande d'utiliser une architecture hexagonale pour les lambdas. [Lire](https://aws.amazon.com/blogs/compute/developing-evolutionary-architecture-with-aws-lambda/)
  
  ```typescript
    import { APIGatewayAuthorizerResult, APIGatewayTokenAuthorizerEvent } from 'aws-lambda';
    import jwt from 'jsonwebtoken';
    import jwksClient from 'jwks-rsa';
    import { Logger } from '@aws-lambda-powertools/logger';
    
    // Initialisation du logger avec la librairie installÃ©e prÃ©cÃ©demment aws-lambda-powertools
    const logger = new Logger({ serviceName: 'lambda-authorizer' });
    
    // DÃ©finition de la fonction lambdaHandler qui sera appelÃ©e par l'API Gateway
    export const lambdaHandler = async (event: APIGatewayTokenAuthorizerEvent): Promise<APIGatewayAuthorizerResult> => {
      logger.info('Le processus authorization commence ...');
    
      // VÃ©rification des variables d'environnement nÃ©cessaires pour le processus d'authorization, elles sont dÃ©finies dans le fichier [infra-as-code/modules/common/03-lambda-authorizer.lambda.tf]().
      if (
        process.env.AUDIENCE === undefined ||
        process.env.JWKS_URI === undefined ||
        process.env.ISSUER_URI === undefined
      ) {
        throw new Error("La variable d'environnement doit contenir AUDIENCE ou JWKS_URI ou ISSUER_URI ");
      }
    
      // RÃ©cupÃ©ration du token d'authentification depuis l'Ã©vÃ©nement
      logger.debug('Event', { event });
      const token = event.authorizationToken.replace('Bearer ', '');
    
      // Initialisation du client JWKS avec l'URI JWKS
      const client = jwksClient({ jwksUri: process.env.JWKS_URI });
    
      try {
        // On commence par dÃ©coder le token pour rÃ©cupÃ©rer les informations nÃ©cessaires pour la vÃ©rification
        const decodedToken = jwt.decode(token, { complete: true });
        logger.debug('Decoded Token', { decodedToken });
    
        // RÃ©cupÃ©ration de l'audience et de l'issuer depuis le token dÃ©codÃ©
        const audience: string = decodedToken?.['payload']['aud'];
        const issuer: string = decodedToken?.['payload']['iss'];
    
        // RÃ©cupÃ©ration de la clÃ© publique depuis le JWKS avec l'ID de la clÃ© (kid)
        const key = await client.getSigningKey(decodedToken?.['header']['kid']);
    
        // VÃ©rification du token avec la clÃ© publique
        jwt.verify(token, key.getPublicKey());
    
        // On vÃ©rifie que l'audience et l'issuer sont corrects, il est possible de pousser encore plus loin en vÃ©rifiant les scopes ou les rÃ´les
        if (audience !== process.env.AUDIENCE) {
          throw new Error('Invalid audience');
        } else if (issuer !== process.env.ISSUER_URI) {
          throw new Error('Invalid issuer');
        }
    
        // Avec le principe de lambda Authorizer, l'Api attend aprÃ¨s une rÃ©ponse de type IAM Policy
      } catch (err) {
        logger.error('Error', { err });
    
        return {
          principalId: 'user',
          policyDocument: {
            Version: '2012-10-17',
            Statement: [
              {
                Action: 'execute-api:Invoke',
                Effect: 'Deny',
                Resource: event.methodArn,
              },
            ],
          },
        };
      }
    
      logger.info('Utilisateur ou service authorise');
      return {
        principalId: 'user',
        policyDocument: {
          Version: '2012-10-17',
          Statement: [
            {
              Action: 'execute-api:Invoke',
              Effect: 'Allow',
              Resource: event.methodArn,
            },
          ],
        },
      };
    };
  
  
  ```
  
  - Maintenant, nous allons crÃ©er un fichier [infra-as-code/modules/common/variables.tf]()  qui va contenir les variables utilisÃ©es ci-dessus :
  
  ```terraform
  variable "apply_custom_domain" {
    type    = bool
    default = false
    description = "Utiliser pour s'avoir si on map l'api gateway Ã  votre domaine via la Route53"
  }
  
  variable "domain" {
    type = string
    description = "Le domaine que vous voulez utiliser pour votre api gateway"
  }
  
  variable "aws_region" {
    type        = string
    default     = "ca-central-1"
    description = "AWS Region, changez par la rÃ©gion de votre choix"
  }
  
  variable "aws_account_id" {
    type = string
    description = "Le numÃ©ro de compte AWS que vous utilisez, vous pouvez le trouver en haut Ã  droite de la console AWS"
  }
  
  variable "issuer_uri" {
    type        = string
    description = "L'url du serveur d'authentification (Auth0/github/entraID) par exemple"
  }
  
  variable "jwks_uri" {
    type        = string
    description = "Le lien vers le fichier jwks.json de votre serveur d'authentification, qui contient les informations de vos clÃ©s publiques"
  }
  
  variable "audience" {
    type = string
    description = "L'audience de votre serveur d'authentification, nous ferons une validation de l'audience dans les tokens JWT"
  }
  ```


  - Le fichier [infra-as-code/modules/common/outputs.tf]() est utilisÃ© pour dÃ©finir les sorties de notre module. Nous allons dÃ©finir les sorties suivantes :

  ```terraform
  output "gateway_api_role" {
    value = {
      name = aws_iam_role.gateway_rest_api_role.name
      arn  = aws_iam_role.gateway_rest_api_role.arn
    }
  }
  output "gateway_api_rest" {
    value = {
      name          = aws_api_gateway_rest_api.this.name
      id            = aws_api_gateway_rest_api.this.id
      execution_arn = aws_api_gateway_rest_api.this.execution_arn
      stage_name    = aws_api_gateway_stage.this.stage_name
      domain_name   = var.apply_custom_domain ? aws_api_gateway_domain_name.this[0].domain_name : null
    }
  }
  
  output "route53_record" {
    value = var.apply_custom_domain ? {
      hostname = aws_route53_record.this[0].fqdn
      records  = aws_route53_record.this[0].records
      type     = aws_route53_record.this[0].type
    } : null
  }
  
  output "acm_certificate" {
    value = var.apply_custom_domain ? {
      certificate_arn       = aws_acm_certificate.this[0].arn
      certificate_authority = aws_acm_certificate.this[0].certificate_authority_arn
    } : null
  }
  ```

- ### Initialisation de l'environnement de dev : 

  Pour chaque environnement, on peut avoir un dossier dans lequel on va initialiser le terraform et appliquer les configurations :
  Par exemple pour dev on : 
  - [infra-as-code/environments/dev/main.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/environments/dev/main.tf) :

  ```terraform
  terraform {
    # Utilisation du provider AWS avec la version 5.86.0
    required_providers {
      aws = {
        source  = "hashicorp/aws"
        version = "5.86.0"
      }
    }
  
    # On utilise le backend S3 pour stocker l'Ã©tat de notre infrastructure avec le bucket S3 aws-serverless-fintech-solution-statefile-bucket-xsxd3 crÃ©e prÃ©cÃ©demment.
    backend "s3" {
      bucket = "aws-serverless-fintech-solution-statefile-bucket-xsxd3" # remplace par votre bucket
      key    = "serverless-app-statefile/default/terraform.tfstate"
      region = "ca-central-1"
  
      #Vous devez avec terraform 1.10.0 et hashicorp/aws 5.86.0 ou plus pour utiliser le verrouillage
      # Lire la documentation pour plus d'informations : https://developer.hashicorp.com/terraform/language/upgrade-guides#s3-native-state-locking
      use_lockfile = true
    }
  }
  
  module "this" {
    source = "../../modules/common"
  
    aws_account_id = var.aws_account_id #remplacez par votre numÃ©ro de compte AWS
    aws_region     = var.aws_region     #remplacez par la region AWS de votre choix
  
    issuer_uri = var.issuer_uri
    jwks_uri   = var.jwks_uri
  
    sms_provider_api_url       = "https://api.nimbasms.com/v1/messages"
    sms_provider_client_id     = var.sms_provider_client_id
    sms_provider_client_secret = var.sms_provider_client_secret
  
    //remplacez par 'ON' pour activer les notifications SMS
    enable_sms_notifications   = "OFF"
  
    //remplacez par 'OFF' pour ne pas activer les notifications EMAIL
    enable_email_notifications = "ON"
  
    //remplacez par votre domaine si apply_custom_domain est true
    domain                     = var.domain
    apply_custom_domain        = true //remplacez par false si vous ne souhaitez pas appliquer de domaine personnalisÃ©
  
    test_destination_email     = var.test_email
  }
  
  ```

- ### Builder le projet de la Lambda Authorizer  :

  Pour builder, zipper et dÃ©placer le zip dans le bon repertoire du module commun, j'utiliserai l'outil [Taskfile](https://taskfile.dev/usage/)
  
  Le script `build-and-deploy-dev`, permet de builder, package en zip et le dÃ©poser dans le dossier commun des modules terraform dans un dossier dist pour que terraform puisse le deployer.
  
 [Taskfile.yml](https://github.com/mombe090/blog-source-code/blob/fintech-solution/Taskfile.yaml) :

  ```yaml
  version: '3'
  
  env:
    # Remplacer par les valeurs de votre environnement
    # Lectures variables d'environnement definies dans le fichier .envrc et definition de nouvelles prefixer TF_VAR_ pour terraform
    TF_VAR_domain: "{{ .FINTECH_SOLUTION_DOMAINE }}"
    TF_VAR_issuer_uri: "{{ .FINTECH_SOLUTION_ISSUER_URI }}"
    TF_VAR_jwks_uri: "{{ .FINTECH_SOLUTION_JWKS_URI }}"
    TF_VAR_audience: "{{ .FINTECH_SOLUTION_AUDIENCE }}"
  
  tasks:
  
    build-and-deploy-dev:
      cmds:
        - task: build-authorizer
        - task: tf-plan-dev
        - task: tf-apply-dev
  
    tf-plan-dev:
      dir: "infra-as-code/environments/dev"
      cmds:
        - terraform init
        - terraform plan
  
    build-authorizer:
      dir: "lambda-src/authorizer"
      cmds:
        - yarn run build
        - cd dist && zip -r authorizer.zip .
        - mkdir -p ../../infra-as-code/modules/common/dist
        - cp dist/authorizer.zip ../../infra-as-code/modules/common/dist/authorizer.zip
  
    tf-apply-dev:
      dir: "infra-as-code/environments/dev"
      cmds:
        - pwd
        - terraform fmt -recursive
        - terraform apply -auto-approve
  
    tf-destroy-dev:
      dir: "infra-as-code/environments/dev"
      cmds:
        - terraform destroy -auto-approve
  
  ```

  Pour build la lambda et dÃ©ployer toutes les resources terraform, exÃ©cutez la commande suivante :

  ```shell
  task build-and-deploy-dev
  
  *
  *
  *
  Apply complete! Resources: 21 added, 0 changed, 0 destroyed.
  
  Outputs:
  
  module_common = {
    "acm_certificate" = {
      "certificate_arn" = "arn:aws:acm:ca-central-1:654654388255:certificate/7b76c99c-b3b6-43ab-9f9d-f120cac9b326"
      "certificate_authority" = ""
    }
    "gateway_api_rest" = {
      "domain_name" = "api.doudhal-devops.com"
      "execution_arn" = "arn:aws:execute-api:ca-central-1:654654388255:mcgh1l274d"
      "id" = "mcgh1l274d"
      "name" = "fintech-solution-api"
      "stage_name" = "dev"
    }
    "gateway_api_role" = {
      "arn" = "arn:aws:iam::654654388255:role/fintech-solution-api-role"
      "name" = "fintech-solution-api-role"
    }
    "lambda_authorizer" = {
      "arn" = "arn:aws:lambda:ca-central-1:654654388255:function:lambda-authorizer"
      "execution_role_arn" = "arn:aws:iam::654654388255:role/lambda-authorizer-role"
      "name" = "lambda-authorizer"
    }
    "route53_record" = {
      "hostname" = "api.doudhal-devops.com"
      "records" = toset(null) /* of string */
      "type" = "A"
    }
  }
  
  ```

- ## VÃ©rification des resources crÃ©er sur la console web d'AWS :

Assurez-vous d'avoir sÃ©lectionner la bonne region  puis rechercher api gateway

![](../assets/img/content/list-api-gw.webp)

Selectionnez parmi la liste `fintech-solution-api` ou le nom que vous avez donner Ã  votre api gateway :
![](../assets/img/content/api-gw-detail.webp)

Sur l'interface Ã  votre menu de gauche, cliquez sur `authorizers` puis sur `JwtAuthorizer`et remplisser le champ `Token value`et cliquez sur `Test Authorizer`

![](../assets/img/content/authorizer-bad.webp)
_On voit que la lambda retourne une policy avec un effet de Deny_

RecupÃ©ration d'un bon token sur **Auth0** :

Connectez-vous sur https://auth0.com puis sur le menu de gauche `Applications -> Apis -> Selectionnez le nom de votre application crÃ©er ci-haut -> Parmi les onglets, choissez Test -> Copiez l'output du curl et executez-le sur un terminal`

![](../assets/img/content/auth0-get-token.webp)

Maintenant coller le token obtenu ci-haut juste aprÃ¨s le **Bearer **

![](../assets/img/content/authorizer-good.webp)
_On voit cette fois-ci la lambda retour une policy avec un effet de Allow_

Afficher les logs de l'authorizer dans cloud watch :
Sur le champs de recherche, tapez `cloud-watch` :

![](../assets/img/content/cloud-watch-authorizer.webp)
_On voit une erreur sur la premiÃ¨re invocation et tous se passe bien pour la sÃ©conde._

### Tester l'Api Gateway via un client http :

![](../assets/img/content/httpie-ui.webp)
_Normal pour le moment l'intÃ©gration entre l'Api Gateway et la lambda get-account-info n'est pas fait_

### Affichage des logs de l'Api pour vÃ©rifier le message d'erreur :
![](../assets/img/content/lambda-404.webp)

## Maintenant on vas ajouter la lambda charger de retourner le solde du compte client avec ses intÃ©grations avec les autres services AWS :



- ### Ajout de la function lambda get account info

[infra-as-code/modules/common/06-get-account-info.lambda.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/06-get-account-info.lambda.tf)
```terraform
  locals {
    get_account_info_name = "get-account-info"
  }
  
  data "aws_iam_policy_document" "get_account_info_lambda_assume_role" {
    statement {
      effect = "Allow"
  
      principals {
        type        = "Service"
        identifiers = ["lambda.amazonaws.com"]
      }
  
      actions = ["sts:AssumeRole"]
    }
  }
  
  data "aws_iam_policy_document" "get_account_info_lambda_policy_document" {
    statement {
      effect = "Allow"
  
      #Autorisation de crÃ©er des logs group, stream et d'envoyer des logs
      actions = [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ]
  
      resources = [
        "arn:aws:logs:${var.aws_region}:${var.aws_account_id}:log-group:/aws/lambda/${local.get_account_info_name}:*"
      ]
    }
  
    statement {
      effect = "Allow"
  
      #Autorisation de dÃ©crypter les donnÃ©es avec la clÃ© KMS
      actions = [
        "kms:Decrypt",
      ]
  
      resources = [
        aws_kms_key.this.arn
      ]
    }
  
    statement {
      effect = "Allow"
  
      #Autorisation de lire les donnÃ©es dans dynamoDB
      actions = [
        "dynamodb:GetItem",
      ]
  
      resources = [
        aws_dynamodb_table.this.arn
      ]
    }
  
    statement {
      effect = "Allow"
  
      #Autorisation d'envoyer des messages dans la SQS
      actions = [
        "sqs:SendMessage",
      ]
  
      resources = [
        aws_sqs_queue.this.arn
      ]
    }
  }
  
  resource "aws_iam_policy" "get_account_info_lambda_policy" {
    name   = "${local.get_account_info_name}-policy"
    policy = data.aws_iam_policy_document.get_account_info_lambda_policy_document.json
  }
  
  resource "aws_iam_role" "get_account_info_lambda_role" {
    name               = "${local.get_account_info_name}-role"
    assume_role_policy = data.aws_iam_policy_document.get_account_info_lambda_assume_role.json
  }
  
  resource "aws_iam_policy_attachment" "get_account_info_lambda_policy_attachment" {
    name       = "${local.get_account_info_name}-policy-attachment"
    roles      = [aws_iam_role.get_account_info_lambda_role.name]
    policy_arn = aws_iam_policy.get_account_info_lambda_policy.arn
  }
  
  #DÃ©claration de la fonction lambda avec le code source zip
  resource "aws_lambda_function" "get_account_info" {
    filename      = "${path.module}/dist/get-account-info.zip"
    function_name = local.get_account_info_name
    role          = aws_iam_role.get_account_info_lambda_role.arn
    handler       = "app.lambdaHandler"
  
    source_code_hash = filebase64sha256("${path.module}/dist/get-account-info.zip")
  
    runtime = "nodejs22.x"
  
    environment {
      variables = {
        aws_region             = var.aws_region
        TABLE_NAME             = aws_dynamodb_table.this.name,
        INIT_ACCOUNT_QUEUE_URL = aws_sqs_queue.this.url
        POWERTOOLS_LOG_LEVEL   = "DEBUG"
      }
    }
  }

```

- [lambda-src/get-account-info/src/app.ts](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/06-get-account-info.lambda.tf) :

```typescript
  import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
  import type { GetItemOutput } from '@aws-sdk/client-dynamodb';
  import { DynamoDBClient, GetItemCommand } from '@aws-sdk/client-dynamodb';
  import type { SendMessageResult } from '@aws-sdk/client-sqs';
  import { SendMessageCommand, SQSClient } from '@aws-sdk/client-sqs';
  import * as process from 'node:process';
  import { Logger } from '@aws-lambda-powertools/logger';
  
  const logger = new Logger({ serviceName: 'get-account-info' });
  
  const awsConfig = {
    region: process.env.REGION,
  };
  
  export const lambdaHandler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
    logger.debug('evenement recu', { event });
  
    try {
      const msisdn: string = event.pathParameters?.msisdn;
  
      // Validation de la presence du numero de telephone dans la requete
      if (!msisdn) {
        logger.error('Le numero de telephone est requis');
        return getApiGatewayProxyResult(400, { message: 'Le numero de telephone est requis' });
      }
  
      // Verification si le numÃ©ro existe en base de donnÃ©es
      const accountInfo = await getAccountInfo(msisdn);
  
      if (!accountInfo.Item) {
        logger.debug('aucun de compte pour ce numero', { msisdn });
        logger.debug('Ajout de message a la queue de creation de compte', { msisdn });
  
        // Ajouter les informations pour initialiser le compte dans la file d'attente, s'il n'existe pas
        await putMessageToInitAccountQueue(getCloudEventFromContext(event));
  
        logger.debug('Message ajoute avec succes', { msisdn });
  
        return getApiGatewayProxyResult(200, {
          message:
            "Vous n'avez pas encore de compte de Paiement Mobile, un message vous sera envoye par SMS pour l'initialiser",
        });
      }
  
      return getApiGatewayProxyResult(200, {
        message: 'account info',
        data: accountInfo.Item,
      });
    } catch (err) {
      logger.error(err);
      return getApiGatewayProxyResult(500, {
        message: "Une erreur s'est produite lors de la recuperation des informations du compte",
      });
    }
  };
  
  # Fonction charger de recuperer les informations du compte dans la table dynamoDB
  export const getAccountInfo = async (msisdn: string): Promise<GetItemOutput> => {
    const client = new DynamoDBClient(awsConfig);
  
    const command = new GetItemCommand({
      TableName: process.env.TABLE_NAME,
      Key: {
        msisdn: { S: msisdn },
      },
    });
    return await client.send(command);
  };
  
  #Fonction chargÃ©e d'envoyer un message Ã  la file d'attente SQS pour la crÃ©ation de compte
  export const putMessageToInitAccountQueue = async (body: any): Promise<SendMessageResult> => {
    const client = new SQSClient({ awsConfig });
  
    const command = new SendMessageCommand({
      QueueUrl: process.env.INIT_ACCOUNT_QUEUE_URL,
      DelaySeconds: 10,
      MessageAttributes: {
        author: {
          DataType: 'String',
          StringValue: 'Mombesoft',
        },
        blogUrl: {
          DataType: 'String',
          StringValue: 'https://mombe090.github.io',
        },
      },
      MessageBody: JSON.stringify(body),
    });
  
    return await client.send(command);
  };
  
  # On utilise cloudEvent pour passer les messages entre les services
  # voir https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md#example
  export const getCloudEventFromContext = (event: APIGatewayProxyEvent) => {
    const date = new Date(event.requestContext.requestTimeEpoch);
  
    return {
      specversion: '1.0',
      type: 'gn.mombesoft.fintech-solution.get-account-info',
      source: 'https://github.com/mombe090/fintech-solution/spec/pull' #remplacer par votre spec,
      subject: 'get account info',
      id: event.requestContext.requestId,
      time: date.toISOString(),
      datacontenttype: 'application/json',
      data: {
        msisdn: event.pathParameters?.msisdn,
      },
    };
  };
  
  export const getApiGatewayProxyResult = (statusCode: number, body: any): APIGatewayProxyResult => {
    return {
      statusCode,
      body: JSON.stringify(body),
    };
  };

```

- ### Ajout de la Table Dynamodb qui vas stocker les informations sur le compte client :

[infra-as-code/modules/common/04-accounts.dynamodb.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/04-accounts.dynamodb.tf)
```terraform
resource "aws_dynamodb_table" "this" {
  name         = "user-account-table"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "msisdn" # numÃ©ro de telephone

  server_side_encryption {
    enabled     = true
    kms_key_arn = aws_kms_key.this.arn
  }

  attribute {
    name = "msisdn"
    type = "S"
  }
}

```

- ### Ajout de la File SQS pour stocker les messages d'ajout de nouveaux clients :

[infra-as-code/modules/common/04-accounts.dynamodb.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/05-init-account.sqs.tf) :

```terraform
locals {
  init_user_account_queue_name = "init-user-account"
}

resource "aws_sqs_queue" "this" {
  name = local.init_user_account_queue_name
}

data "aws_iam_policy_document" "init_user_account_queue_policy_document" {
  statement {
    sid    = uuidv5("dns", "init-user-account-queue-policy-document")
    effect = "Allow"

    principals {
      type        = "AWS"
      identifiers = ["*"]
    }

    actions   = ["sqs:SendMessage"]
    resources = [aws_sqs_queue.this.arn]
    
    #Autorisation pour la lambda get_account_info Ã  envoyer des message dans la queue
    condition {
      test     = "ArnEquals"
      variable = "aws:SourceArn"
      values   = [aws_lambda_function.get_account_info.arn]
    }
  }
}

resource "aws_sqs_queue_policy" "this" {
  queue_url = aws_sqs_queue.this.id
  policy    = data.aws_iam_policy_document.init_user_account_queue_policy_document.json
}

```
- ### Ajout Secret Store Parameter pour enregistrer le client Id et Secret du sms provider 

[infra-as-code/modules/common/07-secret-store.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/07-secret-store.tf) :

```terraform
resource "aws_ssm_parameter" "sms_provider_credentials" {
  name   = "sms_provider_credentials"
  type   = "String"
  key_id = aws_kms_key.this.id
  value = jsonencode({
    "client_id" : var.sms_provider_client_id
    "client_secret" : var.sms_provider_client_secret
    "url" : var.sms_provider_api_url
  })
}

```

- ### Ajout du service de notification par email  :

[infra-as-code/modules/common/08-ses.tf]() :

```terraform
// Creation de l'identitÃ© du domaine dans AWS SES
resource "aws_ses_domain_identity" "domain_identity" {
  count = var.apply_custom_domain ? 1 : 0

  domain = var.domain
}

// Creation de l'identitÃ© du domaine dans AWS SES
resource "aws_ses_domain_dkim" "this" {
  count = var.apply_custom_domain ? 1 : 0

  domain = aws_ses_domain_identity.domain_identity[0].domain
}

# Enregistrement des enregistrements DKIM dans la zone DNS
resource "aws_route53_record" "ses_dkim_record" {
  count = var.apply_custom_domain ? 3 : 0

  zone_id = aws_route53_record.this[0].zone_id
  name    = "${aws_ses_domain_dkim.this[0].dkim_tokens[count.index]}._domainkey"
  type    = "CNAME"
  ttl     = "600"
  records = ["${aws_ses_domain_dkim.this[0].dkim_tokens[count.index]}.dkim.amazonses.com"]
}

# Verification de l'identitÃ© du domaine dans AWS SES
resource "aws_ses_domain_identity_verification" "this" {
  count = var.apply_custom_domain ? 1 : 0

  domain     = aws_ses_domain_identity.domain_identity[0].id
  depends_on = [aws_route53_record.ses_dkim_record]
}

# Ajout de l'identitÃ© de l'email de destination 
resource "aws_ses_email_identity" "email_identity" {
  email = var.test_destination_email
}

```

## Ajout de la lambda pour initialiser un nouveau compte avec 1000 GNF :

[infra-as-code/modules/common/09-init-account.lambda.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/09-init-account.lambda.tf) :

```terraform
locals {
  init_account_name = "init-user-account"
}

data "aws_iam_policy_document" "init_account_lambda_assume_role" {
  statement {
    effect = "Allow"

    principals {
      type        = "Service"
      identifiers = ["lambda.amazonaws.com"]
    }

    actions = ["sts:AssumeRole"]
  }
}

data "aws_iam_policy_document" "init_account_lambda_policy_document" {
  statement {
    effect = "Allow"

    actions = [
      "logs:CreateLogGroup",
      "logs:CreateLogStream",
      "logs:PutLogEvents"
    ]

    resources = [
      "arn:aws:logs:${var.aws_region}:${var.aws_account_id}:log-group:/aws/lambda/${local.init_account_name}:*"
    ]
  }

  statement {
    effect = "Allow"

    actions = [
      "kms:Decrypt",
    ]

    resources = [
      aws_kms_key.this.arn
    ]
  }

  statement {
    effect = "Allow"

    actions = [
      "dynamodb:PutItem",
    ]

    resources = [
      aws_dynamodb_table.this.arn
    ]
  }

  statement {
    effect = "Allow"

    actions = [
      "sqs:ReceiveMessage",
      "sqs:GetQueueAttributes",
      "sqs:DeleteMessage",
    ]

    resources = [
      aws_sqs_queue.this.arn
    ]
  }

  statement {
    effect = "Allow"

    actions = [
      "ssm:GetParameter",
    ]

    resources = [
      aws_ssm_parameter.sms_provider_credentials.arn
    ]
  }

  statement {
    effect = "Allow"

    actions = [
      "ses:SendEmail",
    ]

    resources = [
      aws_ses_domain_identity.domain_identity[0].arn,
      aws_ses_email_identity.email_identity.arn
    ]
  }
}

resource "aws_iam_policy" "init_account_lambda_policy" {
  name   = "${local.init_account_name}-policy"
  policy = data.aws_iam_policy_document.init_account_lambda_policy_document.json
}

resource "aws_iam_role" "init_account_lambda_role" {
  name               = "${local.init_account_name}-role"
  assume_role_policy = data.aws_iam_policy_document.init_account_lambda_assume_role.json
}

resource "aws_iam_policy_attachment" "init_account_lambda_policy_attachment" {
  name       = "${local.init_account_name}-policy-attachment"
  roles      = [aws_iam_role.init_account_lambda_role.name]
  policy_arn = aws_iam_policy.init_account_lambda_policy.arn
}

resource "aws_lambda_function" "init_account_lambda" {
  filename      = "${path.module}/dist/${local.init_account_name}.zip"
  function_name = local.init_account_name
  role          = aws_iam_role.init_account_lambda_role.arn
  handler       = "app.lambdaHandler"

  source_code_hash = filebase64sha256("${path.module}/dist/${local.init_account_name}.zip")

  runtime = "nodejs22.x"

  environment {
    variables = {
      aws_region                                  = var.aws_region
      TABLE_NAME                                  = aws_dynamodb_table.this.name,
      SMS_PROVIDER_API_CREDENTIALS_PARAMETER_NAME = aws_ssm_parameter.sms_provider_credentials.name,
      ENABLE_SMS_NOTIFICATIONS                    = var.enable_sms_notifications,
      ENABLE_EMAIL_NOTIFICATIONS                  = var.enable_email_notifications,
      DOMAIN_NAME                                 = var.domain,
      DESTINATION_EMAIL_EMAIL                     = var.test_destination_email,
      POWERTOOLS_LOG_LEVEL                        = "DEBUG"
    }
  }
}

resource "aws_lambda_event_source_mapping" "this" {
  event_source_arn = aws_sqs_queue.this.arn
  function_name    = aws_lambda_function.init_account_lambda.arn
}

resource "aws_lambda_permission" "allow_sqs_to_invoke_lambda" {
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.init_account_lambda.function_name
  principal     = "sqs.amazonaws.com"
  source_arn    = aws_sqs_queue.this.arn
}

```

- [lambda-src/init-user-account/src/app.ts](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/lambda-src/init-user-account/src/app.ts) :

```typescript
import { SSMClient, GetParameterCommand, GetParameterResult } from '@aws-sdk/client-ssm';
import { DynamoDBClient, PutItemCommand, PutItemOutput } from '@aws-sdk/client-dynamodb';
import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';
import * as process from 'node:process';
import { Logger } from '@aws-lambda-powertools/logger';
import type { SendEmailRequest, SendEmailResponse } from '@aws-sdk/client-ses';

const logger = new Logger({ serviceName: 'get-account-info' });

const awsConfig = {
    region: process.env.REGION,
};

export interface SQSRecord {
    messageId: string;
    receiptHandle: string;
    body: string;
    attributes: SQSRecordAttributes;
    messageAttributes: SQSMessageAttributes;
    md5OfBody: string;
    md5OfMessageAttributes?: string;
    eventSource: string;
    eventSourceARN: string;
    awsRegion: string;
}

export interface SQSEvent {
    Records: SQSRecord[];
}

export const lambdaHandler = async (event: SQSEvent): any => {
    try {
        const records = event.Records;

        for (const record of records) {
            const body = JSON.parse(record.body);

            logger.debug('information sur le nouveau compte', { body });

            const response = await addNewAccount(body.data.msisdn);

            logger.debug('compte crÃ©Ã© avec succÃ¨s !', { response });

            logger.info(
                'var envs : ',
                process.env.ENABLE_SMS_NOTIFICATIONS,
                process.env.ENABLE_EMAIL_NOTIFICATIONS,
                '',
            );

            if (process.env.ENABLE_SMS_NOTIFICATIONS === 'ON') {
                const credential = await getSmsProviderApiCredentials();

                const notification = await sendSmsNotificationToUser(body.data.msisdn, null, credential);
                logger.debug('notification envoyÃ©e avec succÃ¨s !', { notification });
            }

            if (process.env.ENABLE_EMAIL_NOTIFICATIONS === 'ON') {
                const message = `Merci de rejoindre notre service ! Nous sommes ravis de vous avoir Ã  bord. <br />`;

                const notification = await sendEmailNotificationToUser(
                    body.data.msisdn,
                    'Bienvenue sur notre service',
                    message,
                );

                if (notification.$metadata.httpStatusCode !== 200) {
                    logger.error(notification);
                    throw new Error("Erreur lors de l'envoi de la notification", { notification });
                } else {
                    logger.debug('notification envoyÃ©e avec succÃ¨s !', { notification });
                }
            }
        }
    } catch (error) {
        logger.error({ error });
        throw new Error(error);
    }
};

export const addNewAccount = async (msisdn: string): Promise<PutItemOutput> => {
    const client = new DynamoDBClient(awsConfig);

    logger.debug("ajout d'un nouvel utilisateur avec le msisdn suivant : ", { msisdn });
    // https://github.com/aws/aws-sdk-js-v3/blob/main/lib/lib-dynamodb/README.md
    const input = {
        Item: {
            msisdn: {
                S: msisdn,
            },
            balance: {
                N: '1000000',
            }, // Montant initial en GNF
            createdAt: {
                S: new Date().toISOString(),
            },
        },
        TableName: process.env.TABLE_NAME,
    };

    return await client.send(new PutItemCommand(input));
};

export const getSmsProviderApiCredentials = async (): Promise<any> => {
    const client = new SSMClient(awsConfig);
    const command = new GetParameterCommand({
        Name: process.env.SMS_PROVIDER_API_CREDENTIALS_PARAMETER_NAME,
        WithDecryption: true,
    });

    logger.info('RÃ©cupÃ©ration des credentials SMS_PROVIDER_API_KEY et SMS_PROVIDER_API_SECRET');

    const response: GetParameterResult = await client.send(command);

    const { client_id, client_secret, url } = JSON.parse(response.Parameter.Value);

    if (!client_id || !client_secret || !url) {
        throw new Error('le client_id ou client_secret ou url est manquant dans le paramÃ¨tre SSM');
    }

    return { client_id, client_secret, url };
};

export const sendSmsNotificationToUser = async (msisdn: string, message: string, credential): Promise<any> => {
    logger.debug(`Envoi de notification Ã  l'utilisateur ${msisdn} avec le message ${message} via ${credential.url}`);
    const response = await fetch(credential.url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Basic ${Buffer.from(`${credential.client_id}:${credential.client_secret}`).toString(
                'base64',
            )}`,
        },
        body: JSON.stringify({
            to: [msisdn],
            sender_name: 'SMS 9080',
            message:
                message ||
                `Bonjour ceci est just un message de test, votre compte esssaie serverless fintech est active, avec un solde de 10000 frs, vous pouvez commencer Ã  utiliser votre compte.`,
        }),
    });

    if (!response.ok) {
        logger.error(response.body);
        throw new Error('Erreur lors de l envoi de notification' + response.body);
    }

    logger.debug('Server response', { response: await response.json() });

    return await response.json();
};

export const sendEmailNotificationToUser = async (
    msisdn: string,
    title: string,
    message: string,
): Promise<SendEmailResponse> => {
    logger.debug(`Envoi de l email de notification Ã  l'utilisateur ${msisdn} avec le message ${message} `);

    const client = new SESClient(awsConfig);

    const input: SendEmailRequest = {
        Source: `mombe090-github-io-blog@${process.env.DOMAIN_NAME}`,
        Destination: {
            ToAddresses: [process.env.DESTINATION_EMAIL_EMAIL],
        },
        Message: {
            Subject: {
                Data: 'Test from mombe090.github.io blog',
                Charset: 'UTF-8',
            },
            Body: {
                Html: {
                    Data: `
                    <!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <title>Mombe090.github.io blog serverless fintech mobile money tranfert sample</title>
                        </head>
                        <body style="font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; padding: 0;">
                            <div style="width: 100%; max-width: 600px; margin: 0 auto; background-color: #ffffff; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);">
                                <div style="text-align: center; padding: 20px 0; background-color: #007bff; color: #ffffff;">
                                    <h1 style="margin: 0; font-size: 24px;">${title}</h1>
                                </div>
                                <div style="padding: 20px;">
                                    <h2 style="color: #333333; font-size: 20px; margin-top: 0;">Bonjour numÃ©ro ${msisdn},</h2>
                                    <p style="color: #666666; font-size: 16px; line-height: 1.6;"></p>
                                    <p>
                                    ${message}
                                    </p>
                                    <ul style="color: #666666; font-size: 16px; line-height: 1.6;">
                                        <li>Username: nom complet </li>
                                        <li>Email : votre email</li>
                                        
                                    </ul>
                                    <a href="https://mombe0909.github.io" target="_blank" rel="noopener noreferrer" title="https://mombe0909.github.io" style="display: inline-block; padding: 10px 20px; background-color: #007bff; color: #ffffff; text-decoration: none; border-radius: 5px; margin-top: 20px;">Lisez d'autres articles sur le blog.</a>
                                </div>
                                <div style="text-align: center; padding: 20px 0; background-color: #f8f9fa; color: #6c757d;">
                                    <p style="margin: 0; font-size: 14px;">&copy; 2025 Learn, Share, Grow. All rights reserved.</p>
                                </div>
                            </div>
                        </body>
                        </html>
                    `, // required
                    Charset: 'UTF-8',
                },
            },
        },
    };

    return await client.send(new SendEmailCommand(input));
};

```

- [infra-as-code/modules/common/output.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/modules/common/outputs.tf) :

```terraform
output "gateway_api_role" {
  value = {
    name = aws_iam_role.gateway_rest_api_role.name
    arn  = aws_iam_role.gateway_rest_api_role.arn
  }
}
output "gateway_api_rest" {
  value = {
    name          = aws_api_gateway_rest_api.this.name
    id            = aws_api_gateway_rest_api.this.id
    execution_arn = aws_api_gateway_rest_api.this.execution_arn
    stage_name    = aws_api_gateway_stage.this.stage_name
    domain_name   = var.apply_custom_domain ? aws_api_gateway_domain_name.this[0].domain_name : null
  }
}

output "route53_record" {
  value = var.apply_custom_domain ? {
    hostname = aws_route53_record.this[0].fqdn
    records  = aws_route53_record.this[0].records
    type     = aws_route53_record.this[0].type
  } : null
}

output "acm_certificate" {
  value = var.apply_custom_domain ? {
    certificate_arn       = aws_acm_certificate.this[0].arn
    certificate_authority = aws_acm_certificate.this[0].certificate_authority_arn
  } : null
}

output "lambda_authorizer" {
  value = {
    name               = aws_lambda_function.lambda_authorizer.function_name
    arn                = aws_lambda_function.lambda_authorizer.arn
    execution_role_arn = aws_iam_role.lambda_authorizer_role.arn

  }
}

output "dynamo_db_table" {
  value = {
    name = aws_dynamodb_table.this.name
    arn  = aws_dynamodb_table.this.arn
  }
}

output "init_account_sqs_queue" {
  value = {
    name = aws_sqs_queue.this.name
    arn  = aws_sqs_queue.this.arn
    url  = aws_sqs_queue.this.url
  }
}

output "get_account_info_lambda" {
  value = {
    name               = aws_lambda_function.get_account_info.function_name
    arn                = aws_lambda_function.get_account_info.arn
    execution_role_arn = aws_iam_role.get_account_info_lambda_role.arn
  }
}

output "init_account_lambda" {
  value = {
    name               = aws_lambda_function.init_account_lambda.function_name
    arn                = aws_lambda_function.init_account_lambda.arn
    execution_role_arn = aws_iam_role.init_account_lambda_role.arn
  }
}

```

## Ajout de nouvelles variables dans l'environnement de dev :

- [infra-as-code/environments/dev/main.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/environments/dev/main.tf) :
- [infra-as-code/environments/dev/variables.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/environments/dev/variables.tf) :
- [infra-as-code/environments/dev/outputs.tf](https://github.com/mombe090/blog-source-code/blob/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer/infra-as-code/environments/dev/outputs.tf) :

# RÃ©ferences :
- AWS 
- Terraform

### Amusez-vous bien et faites des feedbacks, si Ã§a jamais, il y a un problÃ¨me avec les Ã©tapes ci-haut !

##### L'ensemble du code source utilisÃ© dans ce blog se trouve sur [github](https://github.com/mombe090/blog-source-code/tree/fintech-solution/src/aws-serverless-architecture/mobile-money-transfer)
